---
layout: post
title: "Javascript - Error Handling"
date: 2020-10-11
tags: [JavaScript]
categories:
- Javascript
comments: true
---

## try catch

```javascript
try {

} catch (err) {

}
```

`try catch` 동작 순서

1. `try { ... }` 안의 코드가 실행된다.
2. 에러가 없으면 `catch` 블록은 건너뛰게 된다.
3. 에러가 있으면, `try` 코드 실행이 중단되고 `catch(err)` 블록으로 코드 실행이 넘어가서 변수 `err`에 어떤 에러가 발생했는지에 대한 에러 객체를 담긴 상태로 실행된다.

이렇게 되면, `try {...}` 블록 안에서 에러가 발생하여도 `catch` 에서 에러를 처리하기 때문에 스크립트가 멈추지 않는다.

* `try...catch`는 런타임 에러에서만 동작한다.
* `try...catch`는 동기적으로 동작한다.

setTimeout 같은 비동기적인 코드에서는 `try...catch`로 잡아낼 수 없다. 그래서 비동기적인 코드의 예외를 잡으려면 비동기적인 코드 내부에서 `try...catch`를 구현하여야 한다.

## 에러 객체

자바스크립트는 에러가 발생하면 에러 내용이 담긴 객체를 생성한다. 에러 객체에는 `name`, `message` 프로퍼티가 주로 존재하고 있다.

정확히는 `Error.prototype`으로 존재하고 있다고 한다. 그래서 기본적으로 `constructor`(에러 객체의 프로토타입을 담당하는 생성자 함수)도 가지고 있다.

`constructor`, `name`, `message` 프로퍼티들은 모두 표준 프로퍼티라고 하는데, 여러 브라우저에서 모두 통틀어 가지고 있는 프로퍼티를 표준 프로퍼티라고 하는 것 같다. 즉, 특수한 프로퍼티가 존재하다는 의미인다. 특정 환경(노드, 파이어폭스, 크롬, 엣지, ie10+, 오페라, 사파리6+)에서는 `stack`이라는 비표준 프로퍼티를 가진다. 이 프로퍼티는 에러의 스택 트레이스를 포함한다. 다른 말로 하면 에러를 유발한 중첩 호출들의 순서 정보를 가지고 있는 문자열을 가지고 있으며, 디버깅 목적으로 사용된다.

**stack과 같은 비표준 프로퍼티는 크로스 브라우징 같은 이슈에 문제가 될 수 있으므로, 프로덕션 모드에서는 사용하지 않는 것이 좋다. 모든 사용자들에게 동작하지 않을 것이기 때문이다.**

## catch의 에러 객체 바인딩 유무

최근에 추가된 문법이다.

`try...catch`를 사용할 때, 에러에 대한 정보가 필요하지 않을 경우 `catch`에서 생략이 가능하다.

## throw 연산자

throw 연산자는 에러를 생성한다.

```javascript
throw <error object>
```

throw 뒤에는 에러 객체를 넣는 식으로 문법이 되어있는데, 에러 객체로는 어떤 자료형이라도 넣을 수 있지만, 보통 내장 에러엔 기본적으로 `name`, `message` 프로퍼티를 포함하므로 이 형식을 지키는 것이 좋다.

자바스크립트에서 기본적인 에러 객체를 만들어 낼 수 있는 7가지 에러 생성자가 존재한다. 이 생성자들을 활용하여 에러 객체를 만들 수 있다.

`try...catch`에서 `try` 구문 안에 인위적으로 에러를 생성하면, `catch`문에서 처리할 수 있게 활용할 수 있다.

```javascript
let json = '{ "age": 30 }'; // 불완전한 데이터

try {

  let user = JSON.parse(json); // <-- 에러 없음

  if (!user.name) {
    throw new SyntaxError("불완전한 데이터: 이름 없음"); // (*)
  }

  alert( user.name );

} catch(e) {
  alert( "JSON Error: " + e.message ); // JSON Error: 불완전한 데이터: 이름 없음
}
```

**catch 문에서 나오는 에러는 개발자가 알고 있는 에러여야 한다. 다른 모든 에러는 다시 throw하도록 하여야 한다.**

예상치 못한 에러가 발생하였는데 그것을 `catch`문으로 잡아버리면 디버깅이 어려워진다. 그렇게 되면 밖에서 한 번 더 예상치 못한 에러를 잡아서 에러 객체를 읽을 수 있도록 처리하면 좋다...?

### try...catch...finally

```javascript
try {
   ... 코드를 실행 ...
} catch(e) {
   ... 에러 핸들링 ...
} finally {
   ... 항상 실행 ...
}
```

해당 블록 안의 변수들은 지역 변수이다. 그래서 밖에서 영향을 받을 변수가 있다면 `try...catch` 밖에서 선언을 해주어야할 것이다.

`finally` 절은 항상 실행된다. `try...catch` 안에서 `return`을 사용하여도 `finally` 절은 실행된다.

`try...finally` 구문도 존재한다. 이는 에러 처리를 할 일이 없지만, 시작한 일이 마무리되었는지 확인할 때 쓰인다. 대신 `catch`가 없어서 `try` 안에서 에러가 발생하면 스크립트가 죽을 것이다. **`finally`절은 스크립트가 죽더라도 완료된다.**

