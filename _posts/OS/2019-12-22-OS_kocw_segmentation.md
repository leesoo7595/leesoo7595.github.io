---
layout: post
title: "[OS] Segmentation"
date: 2019-12-22
tags: [OS]
comments: true
---

# Segmentation

페이징은 항상 일정한 크기대로 자르는 것을 의미하지만, 세그멘테이션은 프로세스를 논리적 내용(세그먼트)대로 잘라서 메모리에 배치한다.

* 프로세스는 세그먼트의 집합니다.
* 세그먼트의 크기는 일반적으로 같지 않다.

`프로세스 = 코드(메인루틴 + 서브루틴...) + 데이터 + 스택` (각각을 세그먼트라고 한다.)

세그먼트를 메모리에 할당하게 될 때, 페이지와 마찬가지로 CPU는 각각의 세그먼트가 연속적으로 메모리에 배치되었다고 생각하게끔 해야한다.

그래서 CPU와 메모리 사이에 존재하는 MMU가 여기서도 페이지 테이블과 같은 역할을 하는 **세그먼트 테이블** 역할을 하게 된다. 

여기서 CPU의 논리주소는 둘로 나뉘어질 때, 세그먼트 주소와 displacement로 나뉘어지게 된다.

## 주소변환

* 논리주소 

CPU가 내는 주소를 말한다. `세그먼트 번호 + 변위번호(displacement)`

* 주소변환 : 논리주소 -> 물리주소 (physical address)

세그먼트 테이블 -> base + limit 번호

세그먼트 번호는 세그먼트 테이블 인덱스 값이다. 그리고 세그먼트 번호에 해당되는 테이블 내용에서 시작되는 위치 및 한계값을 파악할 수 있고, 한계값을 넘어서면 segment violation 예외 상황을 처리한다.

세그먼트 번호에서 물리주소를 의미하는 것은 base 번호와 displacement가 된다. 

하지만 세그먼트보단 페이징 기법이 좀 더 일반적으로 사용된다.

## 보호와 공유

* 보호 

모든 주소는 세그먼트 테이블을 공유한다. 세그먼트 테이블 엔트리마다 마찬가지로 접근 제어 방식이 다르게 함으로써 프로세스를 보호한다. 

페이지 단위로 자르게 될 경우, 코드 + 데이터 + 스택이 모두 섞이는 상태에서 일정 크기로 잘리기 때문에 접근 제어 설정이 뒤섞이게 된다. 그래서 논리적으로 나뉘어진게 좀 더 적당하게 접근 제어를 할 수 있게 되기 때문에 페이징보다 더 보호 측면에서는 더 좋다.

## 외부단편화

세그먼트의 크기는 고정식이 아니라 가변식이다. 그래서 프로세스의 크기가 안맞아서 메모리의 비어있는 곳(holes)에 들어갈 수 있는 크기가 안맞기 쉽다. 즉, 외부 단편화의 문제가 생기게된다.

외부 단편화 문제가 해결이 되지 않으면, 메모리 낭비가 너무 커지게 되므로 세그멘테이션만을 사용하기엔 무리가 있다.

### 세그멘테이션 + 페이징

세그멘테이션은 보호와 공유면에서 효과적이다. 페이징은 외부 단편화 문제를 해결해준다. 그래서 프로세스 각각의 세그멘트를 페이징하도록 하여 각각의 문제를 해결한다. (`paged segmentation`)

대신 프로세스를 각각의 세그먼트로 나누는 세그먼트 테이블이 있고, 그 다음에 각각의 세그먼트를 또 페이지 단위로 나누는 페이지 테이블이 있어 CPU와 메모리 사이에 두 개의 테이블을 패스하도록 하여야한다. 그렇게 속도가 좀 느린 경향이 생길 수 있다.
