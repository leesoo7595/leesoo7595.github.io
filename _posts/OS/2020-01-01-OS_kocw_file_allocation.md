---
layout: post
title: "[OS] File allocation"
date: 2020-01-01
tags: [OS]
comments: true
---

# 파일 할당

1. process management
2. main memory management
3. file system *

파일 시스템 중 일부인 파일 할당에 대해서 알아보잣..

OS란, 컴퓨터 시스템의 자원을 관리해주는 것이다. 컴퓨터 시스템에서 CPU - 메인메모리(주기억장치) - 보조기억장치(파일) 순으로 제일 중요하게 나누어진다.

* 섹터와 트랙

섹터는 한 트랙을 일정한 크기(0.5kb)로 쪼갠 덩어리를 말하고, 트랙이란 하드디스크를 뺑뻉(?) 돌릴 때 한 바퀴를 말한다. 하드디스크는 블락 디바이스 -> 캐릭터 디바이스(글자 단위로 자료 이동) 디스크는 항상 블락 단위로 기록이 된다.

## 연속 할당

하드디스크는 내부적으로 (full of free blocks)여러 블럭이 존재한다. 해당 블럭은 연속적으로 존재한다. 일정한 크기로 블럭이 나누어진다고 하는데, 그래서 파일이 하드디스크 안에 존재할 때, 크기가 블럭의 일정한 크기로 나뉘어져서 연속적으로 파일이 존재하게 된다. 

즉, 각 파일에 대해 하드디스크에 연속적으로 블럭에 할당되는 것을 연속 할당이라고 한다. 디스크 헤더가 가장 적게 움직여서(블럭에 저장되도록 움직이는 것) 순서대로 읽을 수 있기 때문에, 속도가 빠르다. 이를 순차 접근이라고도 한다. 또한 이는 특정 부분을 곧바로 읽을 수도 있다. 시작이 0부터라는 것은 당연해서(연속적이라서) 순서를 바로 알기가 쉽기 때문이다.

**연속 할당의 문제점**은, 파일이 삭제될 경우 hole이 생성한다. 파일 생성/삭제가 반복되면 곳곳에 holes이 생성되게 된다. 그렇게 되면 외부 단편화로 인한 디스크 공간 낭비가 생기게 된다. first fit, best fit, worst fit의 경우를 고려하게 되고, compaction(디스크 holes을 한 곳으로 모으게 하는) 작업을 할 수 있지만, 시간이 오래 걸리게 된다. 또한, 파일을 생성하고 나면 파일의 크기를 알 수가 있다. 그리고, 파일의 크기가 증가하는 경우 또한 고려하여야 한다. 파일의 크기가 초기와 다르게 커졌을 경우에, 연속 할당을 하기에 어려움이 생긴다.

위의 단점 때문에 연속 할당 방법을 사용하지 않게 된다.

## 연결 할당

파일을 연결 리스트처럼 하드디스크에 배치한다.

파일 디렉토리의 경우, 제일 처음 블록을 가리키게 된다. 그 후 해당 파일이 있는 블록은 연결 리스트처럼 하드디스크에 할당되도록 한다. 그렇게되면 파일의 크기가 커지더라도, 파일이 서로 떨어지게 되어도 상관없기 때문에 연속 할당의 단점을 커버할 수 있다. 특이점은, 해당 블록의 포인터를 따로 블럭 안에 저장되도록 해야한다. 그래야 해당 파일이 이어져있다는 것을 확인할 수 있기 때문이다. 마지막으로  외부 단편화가 존재할 일이 없어 디스크 낭비는 일어나지 않는다.

**연결 할당의 문제점**은, 특정 부분을 바로 찾을 수가 없어 순서대로 읽어야 한다. 속도가 느려질 수 있다.(파일이 흩어져있어 헤더의 움직임이 커진다.) 또한, 해당 블록의 포인터를 저장해야하기 때문에 기본적으로 4 bytes 이상 손실 된다. 연결 할당의 포인터가 끊어지면 해당 파일의 다음 부분을 읽을 수가 없다. 접근이 불가하게 된다. 

속도가 느려지는 것은 치명적인 단점이 된다. 이를 개선하기 위한 **FAT 파일 시스템**이 있다.

FAT 파일 시스템이란, `file allocation table`의 약자이다. 이 테이블은 하드디스크의 블럭 인덱스만큼 테이블을 가지고 있으며, 해당 테이블에 연결리스트로 되어있는 다음 파일 순서를 가리킨 것을 기록해놓는다. 즉, 포인터들을 테이블에 따로 넣어놓는 것이다.

그렇게 하면, **direct access가 가능하게 되어** 헤더가 움직임이 커질 이유도 없어지고, 속도도 빨라지게 된다. 추후 테이블과 하드디스크가 일치하지 않을 수 있기 때문에 OS에서 주기적으로 테이블과 하드디스크를 체크하여 기록해두도록 한다. 그렇게 되면 신뢰성 문제도 해결하게 된다. FAT는 일반적으로 32비트를 사용하게 된다. 메모리 캐싱으로 쓰인다.

## 색인 할당

`Indexed Allocation` 파일당 한 개의 인덱스 블록이 존재한다. 블록 하나 안에 파일 블록들의 인덱스를 저장해놓고, 해당 인덱스 블록을 참고하여 접근한다. (인덱스 블럭은 포인터의 모음이라고 부르기도 한다.) 디렉토리는 인덱스 블럭을 가리키게 되어있다. 주로 unix / linux 에서 쓰인다.

색인 할당의 장점으로는 direct access가 가능하다. 해당 인덱스 블록으로 바로 접근이 가능하고, 외부 단편화 또한 존재하지 않는다.

색인 할당의 문제점으로는 인덱스 블록 할당에 의한 저장공간을 손실하게 되는 것이다. (1바이트의 인덱스 테이블 저장을 위해 블록 하나를 낭비하기 때문이다. 기본 인덱스 블럭 하나 + 데이터 블럭 여러 개)

1 블럭이 512 바이트인 경우. 4 바이트 * 128 개의 인덱스가 존재할 수 있다. 인덱스 하나의 크기가 4 바이트이다. 프로세스(파일)가 큰 경우, 그래서 인덱스가 하나로 안될 수 있다.

큰 파일을 만들 때, 인덱스 블럭을 하나만 사용하지 않고, 마지막 인덱스가 다른 인덱스 블럭을 가리키도록 한다. 그러면 파일의 크기가 커서 한 인덱스 블럭으로 불가능한 경우, 연결 리스트 방식으로 연결해서 인덱스 블럭을 여러 개 만든다. 이를 `multilevel Index`라고 한다. `combined`는 한 개 이상의 인덱스 블럭을 합치거나 조합하는 것을 말한다.
